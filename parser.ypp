%language "C++"
%skeleton "lalr1.cc"
%require "3.2"

%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define api.parser.class { Parser }
%define api.namespace    { carbonic_c }

%lex-param   { carbonic_c::Lexer &lexer }
%lex-param   { carbonic_c::Driver &driver }
%parse-param { carbonic_c::Lexer &lexer }
%parse-param { carbonic_c::Driver &driver }

%token TK_VAR TK_TYPE
%token TK_INT TK_DOUBLE TK_BOOL TK_STRING TK_CHAR TK_ARRAY TK_RECORD TK_ROUTINE TK_IS TK_NOT
%token TK_WHILE TK_LOOP TK_END TK_FOR TK_FOREACH TK_FROM TK_RETURN
%token TK_IF TK_THEN TK_ELSE TK_IN TK_REVERSE 
%token TK_IDENTIFIER TK_ASSIGN
%token TK_STRING_LITERAL TK_DOUBLE_LITERAL TK_INTEGER_LITERAL TK_CHARACTER_LITERAL TK_TRUE TK_FALSE
%token TK_PRINT
%token TK_CEQ TK_CNEQ TK_CLT TK_CLE TK_CGT TK_CGE
%token TK_LPAREN TK_RPAREN TK_LBRACK TK_RBRACK TK_LSQBRK TK_RSQBRK 
%token TK_SQUOT TK_DOT TK_COMMA TK_COLON TK_SCOLON TK_DDOT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV
%token TK_NEWLINE
%token TK_MOD TK_POW TK_AND TK_OR TK_XOR
%right '='
%left '+' '-'
%left '*' '/'
%right '^'


%type <long long> TK_INTEGER_LITERAL
%type <char> TK_CHARACTER_LITERAL
%type <std::string> TK_STRING_LITERAL
%type <long double> TK_DOUBLE_LITERAL
%type <bool> TK_TRUE TK_FALSE



%code requires {
    #include <iostream>
    #include <string>
    #include <vector>
    #include "lexer.h"

    namespace carbonic_c {
    class Lexer;
    class Driver;
    }
}

%code top {
    #include "lexer.h"
    #include "driver.hpp"

    static carbonic_c::Parser::symbol_type yylex( carbonic_c::Lexer &lexer , carbonic_c::Driver &driver) {
        return lexer.get_next_token();
    }
    // ast::node_ptr<ast::Program> program = std::make_shared<ast::Program>();  // Points to the whole program node.
}


%start Program

%%
Program: //Good
    %empty |
    SimpleDeclaration Program {}| // TOOD: Check which type of recursion is better (left or right)
    RoutineDeclaration Program {}
    ;
SimpleDeclaration: //Good
    VariableDeclaration {}|
    TypeDeclaration {}
    ;
RoutineDeclaration: //Good
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN TK_COLON Type TK_IS Body TK_END {}|
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN TK_IS Body TK_END {}
    ;    
Parameters: //Good
    %empty {}|
    Parameter {}|
    Parameters TK_COMMA Parameter {}
    ;
Parameter: //Good
    TK_IDENTIFIER TK_IS Type {}
    ;
Body: //Good
    %empty {}|
    SimpleDeclaration Body {}|
    Statement Body {}
    ;
Statement: //Okay
    Assignment {}|
    Print {}|
    IfStatement {}|
    WhileLoop {}|
    ForLoop {}|
    ForEachLoop {}|
    RoutineCall TK_SCOLON {}| 
    ReturnStatement {} 
    ;
VariableDeclaration: //Good
    TK_VAR TK_IDENTIFIER TK_COLON Type TK_SCOLON {}|
    TK_VAR TK_IDENTIFIER TK_COLON Type TK_IS Expression TK_SCOLON {}|
    TK_VAR TK_IDENTIFIER TK_IS Expression TK_SCOLON {}
    ; 
TypeDeclaration: //Good
    TK_TYPE TK_IDENTIFIER TK_IS Type TK_SCOLON {}
    ;
Type: //Good
    PrimitiveType {}| 
    ArrayType {}|
    RecordType {}|
    TK_IDENTIFIER {}
    ;
PrimitiveType: //Good 
    TK_INT {}|
    TK_DOUBLE {}|
    TK_BOOL {}|
    TK_CHAR {}| 
    TK_STRING {}
    ;
ArrayType: //Good
    TK_ARRAY TK_LSQBRK Expression TK_RSQBRK Type {} // TODO: Look into nested arrays
    ;
RecordType: //Good
    TK_RECORD VariableDeclarations TK_END {}
    ;
VariableDeclarations: //Okay 
    VariableDeclaration {}|
    VariableDeclaration VariableDeclarations {}
    ;
Assignment: //Good
    ModifiablePrimary TK_ASSIGN Expression TK_SCOLON {}
    ;
Print: //Good
    TK_PRINT TK_LPAREN TK_STRING_LITERAL TK_RPAREN TK_SCOLON {std::cout<<$3<<" ";}| 
    TK_PRINT TK_LPAREN TK_CHARACTER_LITERAL TK_RPAREN TK_SCOLON {std::cout<<$3<<" ";}| 
    TK_PRINT TK_LPAREN TK_NEWLINE TK_RPAREN TK_SCOLON {}|
    TK_PRINT TK_LPAREN ModifiablePrimary TK_RPAREN TK_SCOLON {}
    ;
IfStatement: //Good
    TK_IF Expression TK_THEN Body TK_END {}|
    TK_IF Expression TK_THEN Body TK_ELSE Body TK_END {}
    ;    
WhileLoop: //Good
    TK_WHILE Expression TK_LOOP Body TK_END {}
   ;
ForLoop: //Good
    TK_FOR TK_IDENTIFIER Range TK_LOOP Body TK_END {}
    ;
Range: //Good 
    TK_IN Expression TK_DDOT Expression {}|
    TK_IN TK_REVERSE Expression TK_DDOT Expression {}
    ;
ForEachLoop: //Okay
   TK_FOREACH TK_IDENTIFIER TK_FROM ModifiablePrimary TK_LOOP Body TK_END {}
   ;
RoutineCall: //Okay
    TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN {} // Semi colon in statement no semi colon in expression
    ;
ReturnStatement: //Okay
    TK_RETURN Expression TK_SCOLON {}
    ;
NestedAccess: //...
    %empty {}|
    TK_DOT TK_IDENTIFIER NestedAccess {}|
    TK_LSQBRK Expression TK_RSQBRK NestedAccess {}
    ;
ModifiablePrimary : //... 
    TK_IDENTIFIER {}|
    TK_IDENTIFIER NestedAccess {}|
    ;
Expression: //Good 
    Relation {}|
    Relation TK_AND Expression {}|
    Relation TK_OR Expression {}|
    Relation TK_XOR Expression {}
    ;
Relation: //Good
    Complex {}|
    Complex TK_CEQ Complex {}|
    Complex TK_CNEQ Complex {}|
    Complex TK_CGE Complex {}|
    Complex TK_CGT Complex {}|
    Complex TK_CLT Complex {}|
    Complex TK_CLE Complex {}
    ;
Complex: //Okay
    Simple {}|
    Simple TK_POW Simple {}
    ;
Simple: //Good
    Factor {}|
    Factor TK_MUL Simple {}|
    Factor TK_DIV Simple {}|
    Factor TK_MOD Simple {}
    ;
Factor: //Good
    Summand {}|
    Summand TK_PLUS Factor {}|
    Summand TK_MINUS Factor {}
    ; 
Summand: //Good
    Primary {}|
    TK_LPAREN Primary {}|
    Primary TK_RPAREN {}|
    TK_LPAREN Primary TK_RPAREN {}
;
Primary: //...
    TK_TRUE {}|
    TK_FALSE {}|
    TK_INTEGER_LITERAL {std::cout<<$1<<" ";}|
    TK_NOT TK_INTEGER_LITERAL {std::cout<<$2<<" ";}| //wtf does this even mean? 
    Sign TK_INTEGER_LITERAL {std::cout<<$2<<" ";}| //Sign token is flawed, we should either remove it and only support positive numbers or do something about it in the lexer
    Sign TK_DOUBLE_LITERAL {}|
    TK_DOUBLE_LITERAL {}|
    TK_IDENTIFIER {}|
    ModifiablePrimary {}|
    RoutineCall {}
    ;
Sign: //...
    TK_PLUS {}|
    TK_MINUS {}
    ; 
%%

void carbonic_c::Parser::error(const std::string& msg) {
    std::cerr << msg << '\n';
}
