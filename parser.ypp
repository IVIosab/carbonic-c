%language "C++"
%skeleton "lalr1.cc"
%require "3.2"

%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define api.parser.class { Parser }
%define api.namespace    { carbonic_c }

%lex-param   { carbonic_c::Lexer &lexer }
%lex-param   { carbonic_c::Driver &driver }
%parse-param { carbonic_c::Lexer &lexer }
%parse-param { carbonic_c::Driver &driver }

%token TK_VAR TK_TYPE
%token TK_INT TK_DOUBLE TK_BOOL TK_STRING TK_CHAR TK_ARRAY TK_RECORD TK_ROUTINE TK_IS TK_NOT
%token TK_WHILE TK_LOOP TK_END TK_FOR TK_FOREACH TK_FROM TK_RETURN
%token TK_IF TK_THEN TK_ELSE TK_IN TK_REVERSE 
%token TK_IDENTIFIER TK_ASSIGN
%token TK_STRING_LITERAL TK_DOUBLE_LITERAL TK_INTEGER_LITERAL TK_CHARACTER_LITERAL TK_BOOL_LITERAL
%token TK_PRINT
%token TK_CEQ TK_CNEQ TK_CLT TK_CLE TK_CGT TK_CGE
%token TK_LPAREN TK_RPAREN TK_LBRACK TK_RBRACK TK_LSQBRK TK_RSQBRK 
%token TK_SQUOT TK_DOT TK_COMMA TK_COLON TK_SCOLON TK_DDOT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV
%token TK_NEWLINE
%token TK_MOD TK_POW TK_AND TK_OR TK_XOR

%left TK_OR
%left TK_AND
%left TK_CEQ TK_CNEQ TK_XOR
%left TK_CLT TK_CLE TK_CGT TK_CGE
%left TK_PLUS TK_MINUS
%left TK_MUL TK_DIV TK_MOD
%right TK_POW

%type <long long> TK_INTEGER_LITERAL
%type <std::string> TK_IDENTIFIER
%type <double> TK_DOUBLE_LITERAL
%type <bool> TK_BOOL_LITERAL

%type <ast::node_ptr<ast::Program>> PROGRAM
%type <ast::node_ptr<ast::VariableDeclaration>> VARIABLE_DECLARATION PARAMETER 
%type <std::vector<ast::node_ptr<ast::VariableDeclaration>>> VARIABLE_DECLARATIONS PARAMETERS
%type <ast::node_ptr<ast::TypeDeclaration>> TYPE_DECLARATION 
%type <ast::node_ptr<ast::Type>> TYPE PRIMITIVE_TYPE 
%type <ast::node_ptr<ast::ArrayType>> ARRAY_TYPE
%type <ast::node_ptr<ast::RecordType>> RECORD_TYPE
%type <ast::node_ptr<ast::Expression>> EXPRESSION VALUE
%type <std::vector<ast::node_ptr<ast::Expression>>> EXPRESSIONS
%type <ast::node_ptr<ast::BinaryExpression>> BINARY
%type <ast::node_ptr<ast::BitwiseExpression>> BITWISE
%type <ast::node_ptr<ast::ComparisonExpression>> COMPARISON
%type <ast::node_ptr<ast::RoutineDeclaration>> ROUTINE_DECLARATION
%type <ast::node_ptr<ast::RoutineCall>> ROUTINE_CALL
%type <ast::node_ptr<ast::Statement>> STATEMENT
%type <ast::node_ptr<ast::Return>> RETURN
%type <ast::node_ptr<ast::Print>> PRINT
%type <ast::node_ptr<ast::Body>> BODY
%type <ast::node_ptr<ast::IfStatement> > IF_STATEMENT
%type <ast::node_ptr<ast::ModifiablePrimary>> MODIFIABLE_PRIMARY
%type <ast::node_ptr<ast::WhileLoop>> WHILE_LOOP
%type <ast::node_ptr<ast::ForLoop>> FOR_LOOP
%type <ast::node_ptr<ast::ForeachLoop> > FOREACH_LOOP
//%type <std::vector<ast::nestedAccess>> NESTED_ACCESS
%type <ast::node_ptr<ast::Assignment>> ASSIGNMENT
%type <std::vector<ast::nestedAccess> > NESTED_ACCESS
%code requires {
    #include <iostream>
    #include <string>
    #include <vector>
    #include <variant>
    #include <algorithm>
    #include "ast.hpp"
    namespace carbonic_c {
    class Lexer;
    class Driver;
    }
}

%code top {
    #include <variant>
    #include "lexer.h"
    #include "driver.hpp"
    static carbonic_c::Parser::symbol_type yylex( carbonic_c::Lexer &lexer , carbonic_c::Driver &driver) {
        return lexer.get_next_token();
    }
    ast::node_ptr<ast::Program> program = std::make_shared<ast::Program>();  // Points to the whole program node.
}


%start PROGRAM
%%
PROGRAM:
    %empty {
        //std::cout<< '\n' << std::endl;
    }|
    TYPE_DECLARATION PROGRAM {
        $$ = $2;
    }|
    ROUTINE_DECLARATION PROGRAM{
        $$ = $2;
    };
ROUTINE_DECLARATION:
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN PARAMETERS TK_RPAREN TK_COLON TYPE TK_IS BODY TK_END {
        $$ = std::make_shared<ast::RoutineDeclaration>($2, $4, $7, $9);
        program->routines.push_back($$);
    }|
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN PARAMETERS TK_RPAREN TK_IS BODY TK_END {
        $$ = std::make_shared<ast::RoutineDeclaration>($2, $4, $7);
        program->routines.push_back($$);
    }|
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN TK_RPAREN TK_COLON TYPE TK_IS BODY TK_END {
        $$ = std::make_shared<ast::RoutineDeclaration>($2, std::vector<ast::node_ptr<ast::VariableDeclaration>>(), $6, $8);
        program->routines.push_back($$);
    }|
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN TK_RPAREN TK_IS BODY TK_END {
        $$ = std::make_shared<ast::RoutineDeclaration>($2, std::vector<ast::node_ptr<ast::VariableDeclaration>>(), $6);
        program->routines.push_back($$);
    }
    ;
PARAMETERS:
    PARAMETER {
        $$ = std::vector<ast::node_ptr<ast::VariableDeclaration>>(1, $1);
    }|
    PARAMETERS TK_COMMA PARAMETER{
        $1.push_back($3);
        $$ = $1;
    }
    ;
PARAMETER:
    TK_IDENTIFIER TK_COLON TYPE{
        $$ = std::make_shared<ast::VariableDeclaration>($1, $3);
    }
    ;
BODY:
    %empty {
        std::vector<ast::node_ptr<ast::VariableDeclaration>> tmp1;
        std::vector<ast::node_ptr<ast::Statement>> tmp2;
        $$ = std::make_shared<ast::Body>(tmp1, tmp2);
    }|
    BODY VARIABLE_DECLARATION {
        $1->variables.push_back($2);
        $$ = $1;
    }| 
    BODY STATEMENT {
        $1->statements.push_back($2);
        $$ = $1;
    };
STATEMENT:
    ASSIGNMENT {
        $$ = $1;
    }|
    PRINT {
        $$ = $1;
    }|
    IF_STATEMENT {
        $$ = $1;
    }|
    WHILE_LOOP {
        $$ = $1;
    }|
    FOR_LOOP {
        $$ = $1;
    }|
    FOREACH_LOOP {
        $$ = $1;
    }|
    ROUTINE_CALL TK_SCOLON {
        $$ = $1;
    }| 
    RETURN {
        $$ = $1;
    }; 
ASSIGNMENT:
    MODIFIABLE_PRIMARY TK_ASSIGN EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::Assignment>($1, $3);
    };
PRINT:
    TK_PRINT TK_LPAREN TK_NEWLINE TK_RPAREN TK_SCOLON {
        $$ = std::make_shared<ast::Print>(true);
    }|
    TK_PRINT TK_LPAREN EXPRESSION TK_RPAREN TK_SCOLON{
        $$ = std::make_shared<ast::Print>($3);
    }; 
IF_STATEMENT:
    TK_IF EXPRESSION TK_THEN BODY TK_END {
        $$ = std::make_shared<ast::IfStatement>($2, $4);
    }|
    TK_IF EXPRESSION TK_THEN BODY TK_ELSE BODY TK_END {
        $$ = std::make_shared<ast::IfStatement>($2, $4, $6);
    };
WHILE_LOOP:
    TK_WHILE EXPRESSION TK_LOOP BODY TK_END {
        $$ = std::make_shared<ast::WhileLoop>($2, $4);
    };
FOR_LOOP:
    TK_FOR TK_IDENTIFIER TK_IN EXPRESSION TK_DDOT EXPRESSION TK_LOOP BODY TK_END{
        $$ = std::make_shared<ast::ForLoop>($2, $4, $6, $8);
    }|
    TK_FOR TK_IDENTIFIER TK_IN TK_REVERSE EXPRESSION TK_DDOT EXPRESSION TK_LOOP BODY TK_END{
        $$ = std::make_shared<ast::ForLoop>($2, $7, $5, $9);
    };
FOREACH_LOOP:
   TK_FOREACH TK_IDENTIFIER TK_FROM MODIFIABLE_PRIMARY TK_LOOP BODY TK_END {
        $$ = std::make_shared<ast::ForeachLoop>($2, $4, $6);
    };
RETURN: 
    TK_RETURN EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::Return>($2);
    }; 
VARIABLE_DECLARATION:
    TK_VAR TK_IDENTIFIER TK_COLON TYPE TK_IS EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclaration>($2, $4, $6);
    }|
    TK_VAR TK_IDENTIFIER TK_IS EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclaration>($2, $4);
    }|
    TK_VAR TK_IDENTIFIER TK_COLON TYPE TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclaration>($2, $4);
    };
TYPE_DECLARATION:
    TK_TYPE TK_IDENTIFIER TK_IS TYPE TK_SCOLON {
        $$ = std::make_shared<ast::TypeDeclaration>($2, $4);
    };
TYPE:
    PRIMITIVE_TYPE {
        $$ = $1;
    }|
    TK_IDENTIFIER {
        // $$ = $1;
    }|
    ARRAY_TYPE {
        $$ = $1;
    }|
    RECORD_TYPE {
        $$ = $1;
    };
PRIMITIVE_TYPE:
    TK_INT {
        $$ = std::make_shared<ast::IntType>();
    }|
    TK_DOUBLE {
        $$ = std::make_shared<ast::DoubleType>();
    }|
    TK_BOOL {
        $$ = std::make_shared<ast::BoolType>();
    };
ARRAY_TYPE:
    TK_ARRAY TK_LSQBRK EXPRESSION TK_RSQBRK TYPE {
        $$ = std::make_shared<ast::ArrayType>($3, $5);
    };
RECORD_TYPE:
    TK_RECORD VARIABLE_DECLARATIONS TK_END {
        $$ = std::make_shared<ast::RecordType>($2);
    };
VARIABLE_DECLARATIONS:
    VARIABLE_DECLARATION {
        $$ = std::vector<ast::node_ptr<ast::VariableDeclaration>>(1, $1);
    }|
    VARIABLE_DECLARATIONS VARIABLE_DECLARATION {
        $1.push_back($2);
        $$ = $1;
    };
EXPRESSION: 
    VALUE {
        $$ = $1;
    }|
    BINARY {
        $$ = $1;
    }|
    TK_LPAREN BINARY TK_RPAREN {
        $$ = $2;
    }|
    BITWISE {
        $$ = $1;
    }|
    TK_LPAREN BITWISE TK_RPAREN {
        $$ = $2;
    }|
    COMPARISON {
        $$ = $1;
    }|
    TK_LPAREN COMPARISON TK_RPAREN {
        $$ = $2;
    };
BINARY:
    VALUE TK_PLUS EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::PLUS, $3);
    }|
    VALUE TK_MINUS EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::MINUS, $3);
    }|
    VALUE TK_MUL EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::MUL, $3);
    }|
    VALUE TK_DIV EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::DIV, $3);
    }|
    VALUE TK_POW EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::POW, $3);
    }|
    VALUE TK_MOD EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::MOD, $3);
    };
BITWISE:
    VALUE TK_AND EXPRESSION {
        $$ = std::make_shared<ast::BitwiseExpression>($1, ast::BitwiseOperatorEnum::AND, $3);
    }|
    VALUE TK_OR EXPRESSION {
        $$ = std::make_shared<ast::BitwiseExpression>($1, ast::BitwiseOperatorEnum::OR, $3);
    }|
    VALUE TK_XOR EXPRESSION {
        $$ = std::make_shared<ast::BitwiseExpression>($1, ast::BitwiseOperatorEnum::XOR, $3);
    };
COMPARISON:
    VALUE TK_CEQ EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CEQ, $3);
    }|
    VALUE TK_CNEQ EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CNEQ, $3);
    }|
    VALUE TK_CGE EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CGE, $3);
    }|
    VALUE TK_CGT EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CGT, $3);
    }|
    VALUE TK_CLT EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CLT, $3);
    }|
    VALUE TK_CLE EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CLE, $3);
    };
VALUE:
    TK_BOOL_LITERAL {
        $$ = std::make_shared<ast::BoolLiteral>($1);
    }|
    TK_INTEGER_LITERAL {
        $$ = std::make_shared<ast::IntLiteral>($1);
    }|
    TK_DOUBLE_LITERAL {
        $$ = std::make_shared<ast::DoubleLiteral>($1);
    }|
    MODIFIABLE_PRIMARY {
        $$ = $1; 
    }|
    ROUTINE_CALL {
        $$ = $1;
    }
    ;
ROUTINE_CALL:
    TK_IDENTIFIER TK_LPAREN EXPRESSIONS TK_RPAREN {
        $$ = std::make_shared<ast::RoutineCall>($1, $3);
    }|
    TK_IDENTIFIER TK_LPAREN TK_RPAREN {
        $$ = std::make_shared<ast::RoutineCall>($1, std::vector<ast::node_ptr<ast::Expression>>());
    };
EXPRESSIONS:
    EXPRESSION {
        $$ = std::vector<ast::node_ptr<ast::Expression>>(1, $1);
    }|
    EXPRESSIONS TK_COMMA EXPRESSION {
        $1.push_back($3);
        $$ = $1;
    }; 
NESTED_ACCESS:
    %empty {
        $$ = std::vector<ast::nestedAccess>();
    }|
    TK_DOT TK_IDENTIFIER NESTED_ACCESS{
        $3.push_back($2);
        $$ = $3;
    }|
    TK_LSQBRK EXPRESSION TK_RSQBRK NESTED_ACCESS {
        $4.push_back($2);
        $$ = $4;
    };
MODIFIABLE_PRIMARY : 
    /*TK_IDENTIFIER{
        $$ = std::make_shared<ast::ModifiablePrimary>($1);
    }|
    TK_IDENTIFIER TK_DOT TK_IDENTIFIER{
        $$ = std::make_shared<ast::ModifiablePrimary>($1, $3);
    }|
    TK_IDENTIFIER TK_LSQBRK EXPRESSION TK_RSQBRK{
        $$ = std::make_shared<ast::ModifiablePrimary>($1, $3);
    }; */
    TK_IDENTIFIER NESTED_ACCESS{
        $$ = std::make_shared<ast::ModifiablePrimary>($1, $2);
    };
%%

void carbonic_c::Parser::error(const std::string& msg) {
    std::cerr << msg << '\n';
}