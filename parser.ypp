%language "C++"
%skeleton "lalr1.cc"
%require "3.2"

%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define api.parser.class { Parser }
%define api.namespace    { carbonic_c }

%lex-param   { carbonic_c::Lexer &lexer }
%lex-param   { carbonic_c::Driver &driver }
%parse-param { carbonic_c::Lexer &lexer }
%parse-param { carbonic_c::Driver &driver }

%token TK_VAR TK_TYPE
%token TK_INT TK_DOUBLE TK_BOOL TK_STRING TK_CHAR TK_ARRAY TK_RECORD TK_ROUTINE TK_IS TK_NOT
%token TK_WHILE TK_LOOP TK_END TK_FOR TK_FOREACH TK_FROM TK_RETURN
%token TK_IF TK_THEN TK_ELSE TK_IN TK_REVERSE 
%token TK_IDENTIFIER TK_ASSIGN
%token TK_STRING_LITERAL TK_DOUBLE_LITERAL TK_INTEGER_LITERAL TK_CHARACTER_LITERAL TK_BOOL_LITERAL
%token TK_PRINT
%token TK_CEQ TK_CNEQ TK_CLT TK_CLE TK_CGT TK_CGE
%token TK_LPAREN TK_RPAREN TK_LBRACK TK_RBRACK TK_LSQBRK TK_RSQBRK 
%token TK_SQUOT TK_DOT TK_COMMA TK_COLON TK_SCOLON TK_DDOT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV
%token TK_NEWLINE
%token TK_MOD TK_POW TK_AND TK_OR TK_XOR

%left TK_OR
%left TK_AND
%left TK_CEQ TK_CNEQ TK_XOR
%left TK_CLT TK_CLE TK_CGT TK_CGE
%left TK_PLUS TK_MINUS
%left TK_MUL TK_DIV TK_MOD
%right TK_POW

%type <long long> TK_INTEGER_LITERAL
%type <std::string> TK_IDENTIFIER
%type <double> TK_DOUBLE_LITERAL
%type <bool> TK_BOOL_LITERAL

%type <ast::node_ptr<ast::Program>> PROGRAM
%type <ast::node_ptr<ast::SimpleDeclaration>> SIMPLE_DECLARATION 
%type <ast::node_ptr<ast::VariableDeclaration>> VARIABLE_DECLARATION PARAMETER 
%type <std::vector<ast::node_ptr<ast::VariableDeclaration>>> VARIABLE_DECLARATIONS PARAMETERS
%type <ast::node_ptr<ast::TypeDeclaration>> TYPE_DECLARATION 
%type <ast::node_ptr<ast::Type>> TYPE PRIMITIVE_TYPE 
%type <ast::node_ptr<ast::ArrayType>> ARRAY_TYPE
%type <ast::node_ptr<ast::RecordType>> RECORD_TYPE
%type <ast::node_ptr<ast::Expression>> EXPRESSION VALUE
//%type <std::vector<ast::node_ptr<ast::Expression>>> EXPRESSIONS
%type <ast::node_ptr<ast::BinaryExpression>> BINARY
%type <ast::node_ptr<ast::BitwiseExpression>> BITWISE
%type <ast::node_ptr<ast::ComparisonExpression>> COMPARISON
//%type <ast::node_ptr<ast::ExpressionList>> EXPRESSION_LIST

%code requires {
    #include <iostream>
    #include <string>
    #include <vector>
    #include "ast.hpp"
    namespace carbonic_c {
    class Lexer;
    class Driver;
    }
}

%code top {
    #include "lexer.h"
    #include "driver.hpp"
    
    static carbonic_c::Parser::symbol_type yylex( carbonic_c::Lexer &lexer , carbonic_c::Driver &driver) {
        return lexer.get_next_token();
    }
    ast::node_ptr<ast::Program> program = std::make_shared<ast::Program>();  // Points to the whole program node.
}


%start PROGRAM
%%
PROGRAM:
    %empty {
        std::cout<< '\n' << std::endl;
        $$ = program;
    }|
    SIMPLE_DECLARATION PROGRAM {
        $$ = $2;
    }|
    PARAMETERS {
        std::cout<<"<<PARAMETERS>>"<<std::endl;
    }
    ;
PARAMETERS:
    PARAMETER {
        $$ = std::vector<ast::node_ptr<ast::VariableDeclaration>>(1, $1);
    }|
    PARAMETER TK_COMMA PARAMETERS{
        $3.push_back($1);
        $$ = $3;
    }
PARAMETER:
    TK_IDENTIFIER TK_IS TYPE{
        $$ = std::make_shared<ast::VariableDeclaration>($1, $3);
    }
    ;
SIMPLE_DECLARATION:
    VARIABLE_DECLARATION {
        std::cout<<"<<VARIABLE_DECLARATION>>"<<std::endl;
        $$ = $1;
    }|
    TYPE_DECLARATION {
        std::cout<<"<<TYPE_DECLARATION>>"<<std::endl;
        $$ = $1;
    };
VARIABLE_DECLARATION:
    TK_VAR TK_IDENTIFIER TK_COLON TYPE TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclaration>($2, $4);
    }|
    TK_VAR TK_IDENTIFIER TK_COLON TYPE TK_IS EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclaration>($2, $4, $6);
    }|
    TK_VAR TK_IDENTIFIER TK_IS EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclaration>($2, $4);
    }
    ;
TYPE_DECLARATION:
    TK_TYPE TK_IDENTIFIER TK_IS TYPE TK_SCOLON {
        $$ = std::make_shared<ast::TypeDeclaration>($2, $4);
    };
TYPE:
    PRIMITIVE_TYPE {
    }|
    TK_IDENTIFIER {
    }|
    ARRAY_TYPE {
    }|
    RECORD_TYPE {
    }
    ;
PRIMITIVE_TYPE:
    TK_INT {
        $$ = std::make_shared<ast::IntType>();
    }|
    TK_DOUBLE {
        $$ = std::make_shared<ast::DoubleType>();
    }|
    TK_BOOL {
        $$ = std::make_shared<ast::BoolType>();
    }
    ;
ARRAY_TYPE:
    TK_ARRAY TK_LSQBRK EXPRESSION TK_RSQBRK TYPE {
        $$ = std::make_shared<ast::ArrayType>($3, $5);
    };
RECORD_TYPE:
    TK_RECORD VARIABLE_DECLARATIONS TK_END {
        $$ = std::make_shared<ast::RecordType>($2);
    };
VARIABLE_DECLARATIONS:
    VARIABLE_DECLARATION {
        $$ = std::vector<ast::node_ptr<ast::VariableDeclaration>>(1, $1);
    }|
    VARIABLE_DECLARATION VARIABLE_DECLARATIONS {
        $2.push_back($1);
        $$ = $2;
    };
EXPRESSION: 
    VALUE {
        $$ = $1;
    }|
    BINARY {
        $$ = $1;
    }|
    TK_LPAREN BINARY TK_RPAREN {
        $$ = $2;
    }|
    BITWISE {
        $$ = $1;
    }|
    TK_LPAREN BITWISE TK_RPAREN {
        $$ = $2;
    }|
    COMPARISON {
        $$ = $1;
    }|
    TK_LPAREN COMPARISON TK_RPAREN {
        $$ = $2;
    }
    ;
BINARY:
    VALUE TK_PLUS EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::PLUS, $3);
    }|
    VALUE TK_MINUS EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::MINUS, $3);
    }|
    VALUE TK_MUL EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::MUL, $3);
    }|
    VALUE TK_DIV EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::DIV, $3);
    }|
    VALUE TK_POW EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::POW, $3);
    }|
    VALUE TK_MOD EXPRESSION {
        $$ = std::make_shared<ast::BinaryExpression>($1, ast::BinaryOperatorEnum::MOD, $3);
    }
    ;
BITWISE:
    VALUE TK_AND EXPRESSION {
        $$ = std::make_shared<ast::BitwiseExpression>($1, ast::BitwiseOperatorEnum::AND, $3);
    }|
    VALUE TK_OR EXPRESSION {
        $$ = std::make_shared<ast::BitwiseExpression>($1, ast::BitwiseOperatorEnum::OR, $3);
    }|
    VALUE TK_XOR EXPRESSION {
        $$ = std::make_shared<ast::BitwiseExpression>($1, ast::BitwiseOperatorEnum::XOR, $3);
    }
    ;
COMPARISON:
    VALUE TK_CEQ EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CEQ, $3);
    }|
    VALUE TK_CNEQ EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CNEQ, $3);
    }|
    VALUE TK_CGE EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CGE, $3);
    }|
    VALUE TK_CGT EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CGT, $3);
    }|
    VALUE TK_CLT EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CLT, $3);
    }|
    VALUE TK_CLE EXPRESSION {
        $$ = std::make_shared<ast::ComparisonExpression>($1, ast::ComparisonOperatorEnum::CLE, $3);
    }
    ;
VALUE:
    TK_BOOL_LITERAL {
        $$ = std::make_shared<ast::BoolLiteral>($1);
    }|
    TK_INTEGER_LITERAL {
        $$ = std::make_shared<ast::IntLiteral>($1);
    }|
    TK_DOUBLE_LITERAL {
        $$ = std::make_shared<ast::DoubleLiteral>($1);
    }//|
    //ModifiablePrimary {}|
    //RoutineCall {}|
    /* EXPRESSION_LIST {
        $$ = $1;
    } */
    ;
/* EXPRESSION_LIST:
    TK_LSQBRK EXPRESSIONS TK_RSQBRK{
        $$ = std::make_shared<ast::ExpressionList>($2);
    }
    ;
EXPRESSIONS:
    EXPRESSION {
        $$ = std::vector<ast::node_ptr<ast::Expression>>(1, $1);
    }|
    EXPRESSION TK_COMMA EXPRESSIONS {
        $3.push_back($1);
        $$ = $3;
    }; */
%%

void carbonic_c::Parser::error(const std::string& msg) {
    std::cerr << msg << '\n';
}