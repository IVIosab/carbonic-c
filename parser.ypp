%language "C++"
%skeleton "lalr1.cc"
%require "3.2"

%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define api.parser.class { Parser }
%define api.namespace    { carbonic_c }

%lex-param   { carbonic_c::Lexer &lexer }
%lex-param   { carbonic_c::Driver &driver }
%parse-param { carbonic_c::Lexer &lexer }
%parse-param { carbonic_c::Driver &driver }

%token TK_VAR TK_TYPE
%token TK_INT TK_DOUBLE TK_BOOL TK_STRING TK_CHAR TK_ARRAY TK_RECORD TK_ROUTINE TK_IS TK_NOT
%token TK_WHILE TK_LOOP TK_END TK_FOR TK_FOREACH TK_FROM TK_RETURN
%token TK_IF TK_THEN TK_ELSE TK_IN TK_REVERSE 
%token TK_IDENTIFIER TK_ASSIGN
%token TK_STRING_LITERAL TK_DOUBLE_LITERAL TK_INTEGER_LITERAL TK_CHARACTER_LITERAL TK_TRUE TK_FALSE
%token TK_PRINT
%token TK_CEQ TK_CNEQ TK_CLT TK_CLE TK_CGT TK_CGE
%token TK_LPAREN TK_RPAREN TK_LBRACK TK_RBRACK TK_LSQBRK TK_RSQBRK 
%token TK_SQUOT TK_DOT TK_COMMA TK_COLON TK_SCOLON TK_DDOT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV
%token TK_NEWLINE
%token TK_MOD TK_POW TK_AND TK_OR TK_XOR
%right TK_CEQ
%left TK_PLUS TK_MINUS
%left TK_MUL TK_DIV
%right TK_POW


%type <long long> TK_INTEGER_LITERAL
%type <char> TK_CHARACTER_LITERAL
%type <std::string> TK_STRING_LITERAL TK_IDENTIFIER
%type <long double> TK_DOUBLE_LITERAL
%type <bool> TK_TRUE TK_FALSE

%type <node> Program SimpleDeclaration VariableDeclaration TypeDeclaration Parameter Statement Type PrimitiveType ArrayType RecordType Assignment Print IfStatement WhileLoop ForLoop ForEachLoop RoutineCall ReturnStatement
%type <routineDeclerationNode> RoutineDeclaration
%type <std::vector<node> > Body 
%type <std::vector<variableDeclerationNode>> Parameters VariableDeclarations
%type < std::pair<expressionType, expressionType> >Range
%type <int> Sign
%type <expressionType> Primary Summand Factor Simple Complex Relation Expression
%type < std::vector<variant<identifierNode, expressionNode>> > NestedAccess ModifiablePrimary
%code requires {
    #include <iostream>
    #include <string>
    #include <vector>
    #include <memory>
    #include <variant>
    #include "lexer.h"
    #include "ast.hpp"
    typedef ast::node_ptr<ast::Node>() node;
    typedef ast::node_ptr<ast::RoutineDeclerationNode>() routineDeclerationNode;
    typedef ast::node_ptr<ast::VariableDeclarationNode>() variableDeclerationNode;
    typedef ast::node_ptr<ast::ExpressionNode>()   expressionNode; 
    typedef ast::node_ptr<ast::IdentifierNode>() identifierNode;
    typedef std::variant<ast::node_ptr<ExpressionNode>, ast::node_ptr<IdentifierNode>,
    ast::node_ptr<ast::ArithmeticOperatorNode>, ast::node_ptr<ast::RelationalOperatorNode>, 
    ast::node_ptr<ast::BitwiseOperatorNode> expressionType;
    namespace carbonic_c {
    class Lexer;
    class Driver;
    }
}

%code top {
    #include "lexer.h"
    #include "driver.hpp"

    static carbonic_c::Parser::symbol_type yylex( carbonic_c::Lexer &lexer , carbonic_c::Driver &driver) {
        return lexer.get_next_token();
    }
    ast::node_ptr<ast::Program> program = std::make_shared<ast::Program>();  // Points to the whole program node.
}


%start Program
// potential error: would parser try to make too many empty vectors and rte?
%%
Program:
    %empty {
        std::cout << "Program\n";
        $$ = program;
    }|
    SimpleDeclaration Program {
        $2->variableDeclerations.push_back($1);
        $$ = $2;
    }| // TODO: Check which type of recursion is better (left or right)
    RoutineDeclaration Program {
        std::cout<<"\tRoutineDecleration\n";
        $2->routineList.push_back($1);
        $$ = $2;
    };
SimpleDeclaration:
    VariableDeclaration {
        std::cout<<"\tVariableDecleration\n";
        $$ = $1;
    }|
    TypeDeclaration {
        std::cout<<"\tTypeDecleration\n";
        $$ = $1;
    };
RoutineDeclaration:
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN TK_COLON Type TK_IS Body TK_END {
        $$ = make_shared<ast::RoutineDeclerationNode>($2, $4, $7, $9);
    }|
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN TK_IS Body TK_END {
        $$ = make_shared<ast::RoutineDeclerationNode>($2, $4, $7);
    };    
Parameters:
    %empty {
        $$ = std::vector<ast::shared_ptr<ast::VariableDeclerationNode>>();
        }|
    Parameter {
        $$ = std::vector<ast::shared_ptr<ast::VariableDeclerationNode>>(1, $1);
    }|
    Parameter TK_COMMA Parameters {
      $3.push_back($1);
      $$ = $3;
    };
Parameter:
    TK_IDENTIFIER TK_IS Type {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($1), std::make_shared<ast::TypeNode>($3) );
        };
Body:
    %empty {
        // I want this to be statementNode but it needs to be this to work with SimpleDecleration :/
        $$ = std::vector<ast::node_ptr<ast::Node>>();
    }|
    SimpleDeclaration Body {
        $2.push_back($1);
        $$ = $2;
    }|
    Statement Body {
        $2.push_back($1);
        $$ = $2;
    };
Statement:
    Assignment {
        $$ = $1;
    }|
    Print {
        $$ = $1;
    }|
    IfStatement {
        $$ = $1;
    }|
    WhileLoop {
        $$ = $1;
    }|
    ForLoop {
        $$ = $1;
    }|
    ForEachLoop {
        $$ = $1;
    }|
    RoutineCall TK_SCOLON {
        $$ = $1;
    }| 
    ReturnStatement {
        $$ = $1;
    };
VariableDeclaration:
    TK_VAR TK_IDENTIFIER TK_COLON Type TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($2), std::make_shared<ast::TypeNode>($4) );
    }|
    TK_VAR TK_IDENTIFIER TK_COLON Type TK_IS Expression TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($2), std::make_shared<ast::TypeNode>($4),
        std::make_shared<ast::ExpressionNode>($6) );
    }|
    TK_VAR TK_IDENTIFIER TK_IS Expression TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($2),
        std::make_shared<ast::ExpressionNode>($4) );
    };
TypeDeclaration:
    TK_TYPE TK_IDENTIFIER TK_IS Type TK_SCOLON {
        $$ = std::make_shared<ast::node_ptr<ast::TypeDeclerationNode>>($2, std::make_shared<ast::TypeNode>($4));
    };
Type:
    PrimitiveType {
        $$ = $1;
    }| 
    ArrayType {
        $$ = $1;
    }|
    RecordType {
        $$ = $1;
    }|
    TK_IDENTIFIER {
        $$ = $1;
    };
PrimitiveType:
    TK_INT {
        $$ = std::make_shared<ast::IntNode>();
    }|
    TK_DOUBLE {
        $$ = std::make_shared<ast::DoubleNode>();
    }|
    TK_BOOL {
        $$ = std::make_shared<ast::BoolNode>();
    }|
    TK_CHAR {
        $$ = std::make_shared<ast::CharNode>();
    }| 
    TK_STRING {
        $$ = std::make_shared<ast::StringNode>();
    };
ArrayType:
    TK_ARRAY TK_LSQBRK Expression TK_RSQBRK Type {
        $$ = std::make_shared<ast::ArrayNode>($3, $5);
    };
RecordType:
    TK_RECORD VariableDeclarations TK_END {
        $$ = std::make_shared<ast::RecordNode>($2);
    };
VariableDeclarations:
    VariableDeclaration {
        $$ = std::vector<ast::node_ptr<ast::VariableDecleration>>(1, $1);
    }|
    VariableDeclaration VariableDeclarations {
        $2.push_back($1);
        $$ = $2;
    };
Assignment:
    ModifiablePrimary TK_ASSIGN Expression TK_SCOLON {
        $$ = std::make_shared<ast::AssignmentNode>($1, $3);
    };
Print:
    TK_PRINT TK_LPAREN TK_STRING_LITERAL TK_RPAREN TK_SCOLON {
        std::cout<<$3<<" ";
        $$ = std::make_shared<ast::PrintNode>($3);
    }| 
    TK_PRINT TK_LPAREN TK_CHARACTER_LITERAL TK_RPAREN TK_SCOLON {
        std::cout<<$3<<" ";
        $$ = std::make_shared<ast::PrintNode>($3);
        }| 
    TK_PRINT TK_LPAREN TK_NEWLINE TK_RPAREN TK_SCOLON {
        $$ = std::make_shared<ast::PrintNode>(true);
    }|
    TK_PRINT TK_LPAREN ModifiablePrimary TK_RPAREN TK_SCOLON {
        $$ = std::make_shared<ast::PrintNode>($3);
    }|
    TK_PRINT TK_LPAREN Expression TK_RPAREN TK_SCOLON{
        $$ = std::make_shared<ast::PrintNode>($3);
    };
IfStatement:
    TK_IF Expression TK_THEN Body TK_END {
        $$ = std::make_shared<ast::IfStatementNode>($2, $4);
    }|
    TK_IF Expression TK_THEN Body TK_ELSE Body TK_END {
        $$ = std::make_shared<ast::IfStatementNode>($2, $4, $6)
    };    
WhileLoop:
    TK_WHILE Expression TK_LOOP Body TK_END {
        $$ = std::make_shared<ast::WhileNode>($2, $4);
    };
ForLoop:
    TK_FOR TK_IDENTIFIER Range TK_LOOP Body TK_END {
        $$ = std::make_shared<ast::ForNode(
            std::make_shared<ast::IdentifierNode>($2),
            $3.first, $3.second, $5)
    };
Range:
    TK_IN Expression TK_DDOT Expression {
        $$ = std::make_pair<$2, $4>;
    }|
    TK_IN TK_REVERSE Expression TK_DDOT Expression {
        $$ = std::make_pair<$5, $3>;
    };
ForEachLoop:
   TK_FOREACH TK_IDENTIFIER TK_FROM ModifiablePrimary TK_LOOP Body TK_END {
        $$ = std::make_shared<ast::ForEachNode>(
            std::make_shared<ast::IdentifierNode>($2), $4, $6)
   };
RoutineCall:
    TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN {
        $$ = std::make_shared<ast::RoutineCallNode>($1, $3);
    }; // Semi colon in statement no semi colon in expression
ReturnStatement: //Okay
    TK_RETURN Expression TK_SCOLON {
        $$ = std::make_shared<ast::ReturnStatementNode>($2);
    };
NestedAccess:
    %empty {
        $$ = std::vector<variant<ast::node_ptr<ast::IdentifierNode>, ast::node_ptr<ast::ExpressionNode>>>();
    }|
    TK_DOT TK_IDENTIFIER NestedAccess {
        $3.push_back(std::make_shared<ast::IdentifierNode>($2));
        $$ = $3;
    }|
    TK_LSQBRK Expression TK_RSQBRK NestedAccess {
        $4.push_back(std::make_shared<ast::IdentifierNode>($2));
        $$ = $4;
    };
ModifiablePrimary : 
    // TK_IDENTIFIER {}| useless, covered in nested access
    TK_IDENTIFIER NestedAccess {
        $2.push_back(std::make_shared<ast::IdentifierNode>($1));
        $$ = $2;
    };
Expression: 
    Relation {
        $$ = $1;
    }|
    Relation TK_AND Expression {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($1,
        ast::bitwiseOperatorEnum::AND, $3);
    }|
    Relation TK_OR Expression {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($1,
        ast::bitwiseOperatorEnum::OR, $3);
    }|
    Relation TK_XOR Expression {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($1,
        ast::bitwiseOperatorEnum::XOR, $3);
    };
Relation:
    Complex {
        $$ = $1;
    }|
    Complex TK_CEQ Complex {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CEQ, $3);
    }|
    Complex TK_CNEQ Complex {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CNEQ, $3);
    }|
    Complex TK_CGE Complex {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CGE, $3);
    }|
    Complex TK_CGT Complex {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CGT, $3);
    }|
    Complex TK_CLT Complex {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CLT, $3);
    }|
    Complex TK_CLE Complex {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CLE, $3);
    };
Complex:
    Simple {
        $$ = $1;
    }|
    Simple TK_POW Simple {
        std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::POW, $3);
    };
Simple:
    Factor {
        $$ = $1;
    }|
    Factor TK_MUL Simple {
        $$ = std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::MUL, $3);
    }|
    Factor TK_DIV Simple {
        std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::DIV, $3);
    }|
    Factor TK_MOD Simple {
        std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::MOD, $3);
    };
Factor:
    Summand {
        $$ = $1;
    }|
    Summand TK_PLUS Factor {
        $$ = std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::PLUS, $3);
    }|
    Summand TK_MINUS Factor {
        $$ = std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::MINUS, $3);
    }; 
// This doesn't care if we get unclosed paranthesis, is this a syntax error or a symantic error?
Summand:
    Primary {
        $$ = $1;
    }|
    TK_LPAREN Primary {
        $$ = ($2;
    }|
    Primary TK_RPAREN {
        $$ = $1);
    }|
    TK_LPAREN Primary TK_RPAREN {
        $$ = ($2);
    };
Primary:
    TK_TRUE {
        $$ = true;
    }|
    TK_FALSE {
        $$ = false;
    }|
    TK_INTEGER_LITERAL {
        std::cout<<$1<<" ";
        $$ = $1;
    }|
    TK_NOT TK_INTEGER_LITERAL {
        std::cout<<$2<<" ";
        $$ = (! $2);
    }|
    Sign TK_INTEGER_LITERAL {
        std::cout<<$2<<" ";
        $$ = ($1 * $2);   
    }|
    Sign TK_DOUBLE_LITERAL {
        $$ = ($1 * $2);
    }|
    TK_DOUBLE_LITERAL {
        $$ = $1;
    }|
    // TK_IDENTIFIER {} redundant, removed because ALready covered in modifable primary.4
    ModifiablePrimary {
        $$ = $1;
    }|
    RoutineCall {
        $$ = $1;
    };
Sign:
    TK_PLUS {
        $$ = 1;
    }|
    TK_MINUS {
        $$ = -1;
    };
%%

void carbonic_c::Parser::error(const std::string& msg) {
    std::cerr << msg << '\n';
}