%language "C++"
%skeleton "lalr1.cc"
%require "3.2"

%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define api.parser.class { Parser }
%define api.namespace    { carbonic_c }

%lex-param   { carbonic_c::Lexer &lexer }
%lex-param   { carbonic_c::Driver &driver }
%parse-param { carbonic_c::Lexer &lexer }
%parse-param { carbonic_c::Driver &driver }

%token TK_VAR TK_TYPE
%token TK_INT TK_DOUBLE TK_BOOL TK_STRING TK_CHAR TK_ARRAY TK_RECORD TK_ROUTINE TK_IS TK_NOT
%token TK_WHILE TK_LOOP TK_END TK_FOR TK_FOREACH TK_FROM TK_RETURN
%token TK_IF TK_THEN TK_ELSE TK_IN TK_REVERSE 
%token TK_IDENTIFIER TK_ASSIGN
%token TK_STRING_LITERAL TK_DOUBLE_LITERAL TK_INTEGER_LITERAL TK_CHARACTER_LITERAL TK_TRUE TK_FALSE
%token TK_PRINT
%token TK_CEQ TK_CNEQ TK_CLT TK_CLE TK_CGT TK_CGE
%token TK_LPAREN TK_RPAREN TK_LBRACK TK_RBRACK TK_LSQBRK TK_RSQBRK 
%token TK_SQUOT TK_DOT TK_COMMA TK_COLON TK_SCOLON TK_DDOT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV
%token TK_NEWLINE
%token TK_MOD TK_POW TK_AND TK_OR TK_XOR
%right TK_CEQ
%left TK_PLUS TK_MINUS
%left TK_MUL TK_DIV
%right TK_POW


%type <long long> TK_INTEGER_LITERAL
%type <char> TK_CHARACTER_LITERAL
%type <std::string> TK_STRING_LITERAL
%type <long double> TK_DOUBLE_LITERAL
%type <bool> TK_TRUE TK_FALSE

%type ast::node_ptr<ast::Node>() Program SimpleDeclaration VariableDeclaration TypeDeclaration 
RoutineDeclaration Parameter Statement Type PrimitiveType ArrayType RecordType
%type std::vector<ast::node_ptr<ast::Node>> Parameters Body VariableDeclarations

%code requires {
    #include <iostream>
    #include <string>
    #include <vector>
    #include <memory>
    #include "lexer.h"
    #include "ast.hpp"
    namespace carbonic_c {
    class Lexer;
    class Driver;
    }
}

%code top {
    #include "lexer.h"
    #include "driver.hpp"

    static carbonic_c::Parser::symbol_type yylex( carbonic_c::Lexer &lexer , carbonic_c::Driver &driver) {
        return lexer.get_next_token();
    }
    ast::node_ptr<ast::Program> program = std::make_shared<ast::Program>();  // Points to the whole program node.
}


%start Program
// potential error: would parser try to make too many empty vectors and rte?
%%
Program:
    %empty {
        std::cout << "Program\n";
        $$ = program;
    }|
    SimpleDeclaration Program {
        $2->variableDeclerations.push_back($1);
        $$ = $2;
    }| // TODO: Check which type of recursion is better (left or right)
    RoutineDeclaration Program {
        std::cout<<"\tRoutineDecleration\n";
        $2->routineList.push_back($1);
        $$ = $2;
    };
SimpleDeclaration:
    VariableDeclaration {
        std::cout<<"\tVariableDecleration\n";
        $$ = $1;
    }|
    TypeDeclaration {
        std::cout<<"\tTypeDecleration\n";
        $$ = $1;
    };
RoutineDeclaration:
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN TK_COLON Type TK_IS Body TK_END {
        $$ = make_shared<ast::RoutineDeclerationNode>($4, $7, $9);
    }|
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN TK_IS Body TK_END {
        $$ = make_shared<ast::RoutineDeclerationNode>($4, $7);
    };    
Parameters:
    %empty {
        $$ = std::vector<ast::shared_ptr<ast::VariableDeclerationNode>>();
        }|
    Parameter {
        $$ = std::vector<ast::shared_ptr<ast::VariableDeclerationNode>>(1, $1);
    }|
    Parameter TK_COMMA Parameters {
      $3.push_back($1);
      $$ = $3;
    }
    ;
Parameter:
    TK_IDENTIFIER TK_IS Type {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::TypeNode>($3), std::make_shared<ast::IdentifierNode>($1) );
        };
Body:
    %empty {
        // tI want this to be statementNode but it needs to be this to work with SimpleDecleratoin :/
        $$ = std::vector<ast::node_ptr<ast::Node>>();
    }|
    SimpleDeclaration Body {
        $2.push_back($1);
        $$ = $2;
    }|
    Statement Body {
        $2.push_back($1);
        $$ = $2;
    };
Statement:
    Assignment {
        $$ = $1;
    }|
    Print {
        $$ = $1;
    }|
    IfStatement {
        $$ = $1;
    }|
    WhileLoop {
        $$ = $1;
    }|
    ForLoop {
        $$ = $1;
    }|
    ForEachLoop {
        $$ = $1;
    }|
    RoutineCall TK_SCOLON {
        $$ = $1;
    }| 
    ReturnStatement {
        $$ = $1;
    };
VariableDeclaration:
    TK_VAR TK_IDENTIFIER TK_COLON Type TK_SCOLON {
        $$ = std::make_shared<ast::node_ptr<ast::VariableDeclerationNode>>($2, $4);
    }|
    TK_VAR TK_IDENTIFIER TK_COLON Type TK_IS Expression TK_SCOLON {
        $$ = std::make_shared<ast::node_ptr<ast::VariableDeclerationNode>>($2, $4, $6);
    }|
    TK_VAR TK_IDENTIFIER TK_IS Expression TK_SCOLON {
        $$ = std::make_shared<ast::node_ptr<ast::VariableDeclerationNode>>($2, $4);
    };
TypeDeclaration:
    TK_TYPE TK_IDENTIFIER TK_IS Type TK_SCOLON {
        $$ = std::make_shared<ast::node_ptr<ast::TypeDeclerationNode>>($2, $4);
    };
Type:
    PrimitiveType {
        $$ = $1;
    }| 
    ArrayType {
        $$ = $1;
    }|
    RecordType {
        $$ = $1;
    }|
    TK_IDENTIFIER {
        $$ = $1;
    };
PrimitiveType:
    TK_INT {
        $$ = std::make_shared<ast::IntNode>();
    }|
    TK_DOUBLE {
        $$ = std::make_shared<ast::DoubleNode>();
    }|
    TK_BOOL {
        $$ = std::make_shared<ast::BoolNode>();
    }|
    TK_CHAR {
        $$ = std::make_shared<ast::CharNode>();
    }| 
    TK_STRING {
        $$ = std::make_shared<ast::StringNode>();
    };
ArrayType:
    TK_ARRAY TK_LSQBRK Expression TK_RSQBRK Type {
        $$ = std::make_shared<ast::ArrayNode>($3, $5);
    };
RecordType: //Good
    TK_RECORD VariableDeclarations TK_END {
        $$ = std::make_shared<ast::RecordNode($2);
    };
VariableDeclarations:
    VariableDeclaration {
        $$ = std::vector<ast::node_ptr<ast::VariableDecleration>>(1, $1);
    }|
    VariableDeclaration VariableDeclarations {
        $2.push_back($1);
        $$ = $2;
    };
Assignment:
    ModifiablePrimary TK_ASSIGN Expression TK_SCOLON {}
    ;
Print: //Good
    TK_PRINT TK_LPAREN TK_STRING_LITERAL TK_RPAREN TK_SCOLON {std::cout<<$3<<" ";}| 
    TK_PRINT TK_LPAREN TK_CHARACTER_LITERAL TK_RPAREN TK_SCOLON {std::cout<<$3<<" ";}| 
    TK_PRINT TK_LPAREN TK_NEWLINE TK_RPAREN TK_SCOLON {}|
    TK_PRINT TK_LPAREN ModifiablePrimary TK_RPAREN TK_SCOLON {}
    ;
IfStatement: //Good
    TK_IF Expression TK_THEN Body TK_END {}|
    TK_IF Expression TK_THEN Body TK_ELSE Body TK_END {}
    ;    
WhileLoop: //Good
    TK_WHILE Expression TK_LOOP Body TK_END {}
   ;
ForLoop: //Good
    TK_FOR TK_IDENTIFIER Range TK_LOOP Body TK_END {}
    ;
Range: //Good 
    TK_IN Expression TK_DDOT Expression {}|
    TK_IN TK_REVERSE Expression TK_DDOT Expression {}
    ;
ForEachLoop: //Okay
   TK_FOREACH TK_IDENTIFIER TK_FROM ModifiablePrimary TK_LOOP Body TK_END {}
   ;
RoutineCall: //Okay
    TK_IDENTIFIER TK_LPAREN Parameters TK_RPAREN {} // Semi colon in statement no semi colon in expression
    ;
ReturnStatement: //Okay
    TK_RETURN Expression TK_SCOLON {}
    ;
NestedAccess: //...
    %empty {}|
    TK_DOT TK_IDENTIFIER NestedAccess {}|
    TK_LSQBRK Expression TK_RSQBRK NestedAccess {}
    ;
ModifiablePrimary : //... 
    // TK_IDENTIFIER {}| useless, covered in nested access
    TK_IDENTIFIER NestedAccess {}
    ;
Expression: //Good 
    Relation {}|
    Relation TK_AND Expression {}|
    Relation TK_OR Expression {}|
    Relation TK_XOR Expression {}
    ;
Relation: //Good
    Complex {}|
    Complex TK_CEQ Complex {}|
    Complex TK_CNEQ Complex {}|
    Complex TK_CGE Complex {}|
    Complex TK_CGT Complex {}|
    Complex TK_CLT Complex {}|
    Complex TK_CLE Complex {}
    ;
Complex: //Okay
    Simple {}|
    Simple TK_POW Simple {}
    ;
Simple: //Good
    Factor {}|
    Factor TK_MUL Simple {}|
    Factor TK_DIV Simple {}|
    Factor TK_MOD Simple {}
    ;
Factor: //Good
    Summand {}|
    Summand TK_PLUS Factor {}|
    Summand TK_MINUS Factor {}
    ; 
// This doesn't care if we get unclosed paranthesis, is this a syntax error or a symantic error?
Summand: //Good
    Primary {}|
    TK_LPAREN Primary {}|
    Primary TK_RPAREN {}|
    TK_LPAREN Primary TK_RPAREN {}
;
Primary: //...
    TK_TRUE {}|
    TK_FALSE {}|
    TK_INTEGER_LITERAL {std::cout<<$1<<" ";}|
    TK_NOT TK_INTEGER_LITERAL {std::cout<<$2<<" ";}|
    Sign TK_INTEGER_LITERAL {std::cout<<$2<<" ";}| //Sign token is flawed, we should either remove it and only support positive numbers or do something about it in the lexer
    Sign TK_DOUBLE_LITERAL {}|
    TK_DOUBLE_LITERAL {}|
    // TK_IDENTIFIER {} redundant, removed because ALready covered in modifable primary.4
    ModifiablePrimary {}|
    RoutineCall {}
    ;
Sign:
    TK_PLUS {}|
    TK_MINUS {}
    ; 
%%

void carbonic_c::Parser::error(const std::string& msg) {
    std::cerr << msg << '\n';
}