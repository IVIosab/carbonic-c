%language "C++"
%skeleton "lalr1.cc"
%require "3.2"

%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define api.parser.class { Parser }
%define api.namespace    { carbonic_c }

%lex-param   { carbonic_c::Lexer &lexer }
%lex-param   { carbonic_c::Driver &driver }
%parse-param { carbonic_c::Lexer &lexer }
%parse-param { carbonic_c::Driver &driver }

%token TK_VAR TK_TYPE                                   // var type
%token TK_INT TK_DOUBLE TK_BOOL TK_STRING TK_CHAR       // integer double boolean string char
%token TK_ARRAY TK_RECORD TK_ROUTINE TK_IS TK_NOT       // array record routine is !
%token TK_WHILE TK_LOOP TK_END TK_FOR TK_FOREACH        // while loop end for foreach
%token TK_FROM TK_RETURN                                // from return
%token TK_IF TK_THEN TK_ELSE TK_IN TK_REVERSE           // if then else in reverse
%token TK_IDENTIFIER TK_ASSIGN                          // [a-zA-Z_][a-zA-Z0-9_]* :=
%token TK_STRING_LITERAL TK_DOUBLE_LITERAL              // \"([^\\\"]|\\.)*\" [0-9]+\.[0-9]+  
%token TK_INTEGER_LITERAL TK_CHARACTER_LITERAL          // [0-9]+ .
%token TK_TRUE TK_FALSE                                 // true false
%token TK_PRINT                                         // print
%token TK_CEQ TK_CNEQ TK_CLT TK_CLE TK_CGT TK_CGE       // = /= < <= > >=
%token TK_LPAREN TK_RPAREN                              // ( )
%token TK_LBRACK TK_RBRACK                              // { }
%token TK_LSQBRK TK_RSQBRK                              // [ ]
%token TK_SQUOT TK_DOT TK_COMMA                         // ' . , 
%token TK_DDOT TK_COLON TK_SCOLON                       // .. : ;
%token TK_PLUS TK_MINUS TK_MUL TK_DIV                   // + - * /
%token TK_NEWLINE                                       // newline
%token TK_MOD TK_POW TK_AND TK_OR TK_XOR                // % ** and or xor

%right TK_CEQ
%left TK_PLUS TK_MINUS
%left TK_MUL TK_DIV
%right TK_POW

%type <long long> TK_INTEGER_LITERAL
%type <char> TK_CHARACTER_LITERAL
%type <std::string> TK_STRING_LITERAL TK_IDENTIFIER
%type <long double> TK_DOUBLE_LITERAL
%type <bool> TK_TRUE TK_FALSE

%type <ast::node_ptr<ast::Program>> PROGRAM
%type <ast::node_ptr<ast::SimpleDeclaration>> SIMPLE_DECLARATION
%type <ast::node_ptr<ast::TypeDeclaration>> TYPE_DECLARATION
%type <ast::node_ptr<ast::VariableDeclaration>> VARIABLE_DECLARATION

%type <ast::node_ptr<ast::Type>> TYPE PRIMITIVE_TYPE ARRAY_TYPE RECORD_TYPE
%type <ast::node_ptr<ast::Body>> BODY
%type <ast::node_ptr<ast::Identifier>> MODIFIABLE_PRIMARY
%type <ast::node_ptr<ast::Statement>> STATEMENT
%type <ast::node_ptr<ast::Return>> RETURN
%type <ast::node_ptr<ast::Print>> PRINT
%type <ast::node_ptr<ast::Assignment>> ASSIGNMENT
%type <ast::node_ptr<ast::IfStatement>> IF_STATEMENT
%type <ast::node_ptr<ast::WhileLoop>> WHILE_LOOP
%type <ast::node_ptr<ast::ForLoop>> FOR_LOOP
%type <ast::node_ptr<ast::RoutineCall>> ROUTINE_CALL

%type <ast::node_ptr<ast::Expression>> EXPRESSION
%type <std::vector<ast::node_ptr<ast::Expression>>> EXPRESSION_LIST
%type <ast::node_ptr<ast::RoutineDeclaration>> ROUTINE_DECLARATION
%type <ast::node_ptr<ast::VariableDeclaration>> PARAMETER
%type <std::vector<ast::node_ptr<ast::VariableDeclaration>>> PARAMETERS
%type <std::vector<ast::node_ptr<ast::VariableDeclaration>>> VARIABLE_DECLARATIONS


%code requires {
    #include <iostream>
    #include <string>
    #include <vector>
    #include "ast.hpp"
    namespace carbonic_c {
    class Lexer;
    class Driver;
    }
}

%code top {
    #include "lexer.h"
    #include "driver.hpp"
    static carbonic_c::Parser::symbol_type yylex( carbonic_c::Lexer &lexer , carbonic_c::Driver &driver) {
        return lexer.get_next_token();
    }
    ast::node_ptr<ast::Program> program = std::make_shared<ast::Program>();  // Points to the whole program node.
}


%start PROGRAM
// potential error: would parser try to make too many empty vectors and rte?
%%
PROGRAM:
    %empty {
        std::cout << "Program\n";
        $$ = program;
    }|
    SIMPLE_DECLARATION PROGRAM {
        $2->variableDeclerations.push_back($1);
        $$ = $2;
    }| // TODO: Check which type of recursion is better (left or right)
    ROUTINE_DECLARATION PROGRAM {
        std::cout<<"\tRoutineDecleration\n";
        $2->routineList.push_back($1);
        $$ = $2;
    };
SIMPLE_DECLARATION:
    VARIABLE_DECLARATION {
        std::cout<<"\tVariableDecleration\n";
        $$ = $1;
    }|
    TYPE_DECLARATION {
        std::cout<<"\tTypeDecleration\n";
        $$ = $1;
    };
ROUTINE_DECLARATION:
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN PARAMETERS TK_RPAREN TK_COLON TYPE TK_IS BODY TK_END {
        $$ = make_shared<ast::RoutineDeclerationNode>($2, $4, $7, $9);
    }|
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN PARAMETERS TK_RPAREN TK_IS BODY TK_END {
        $$ = make_shared<ast::RoutineDeclerationNode>($2, $4, $7);
    };    
PARAMETERS:
    %empty {
        $$ = std::vector<ast::shared_ptr<ast::VariableDeclerationNode>>();
        }|
    PARAMETER {
        $$ = std::vector<ast::shared_ptr<ast::VariableDeclerationNode>>(1, $1);
    }|
    PARAMETER TK_COMMA PARAMETERS {
      $3.push_back($1);
      $$ = $3;
    };
PARAMETER:
    TK_IDENTIFIER TK_IS TYPE {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($1), std::make_shared<ast::TypeNode>($3) );
        };
BODY:
    %empty {
        // I want this to be statementNode but it needs to be this to work with SimpleDecleration :/
        $$ = std::vector<ast::node_ptr<ast::Node>>();
    }|
    SIMPLE_DECLARATION BODY {
        $2.push_back($1);
        $$ = $2;
    }|
    STATEMENT BODY {
        $2.push_back($1);
        $$ = $2;
    };
STATEMENT:
    ASSIGNMENT {
        $$ = $1;
    }|
    PRINT {
        $$ = $1;
    }|
    IF_STATEMENT {
        $$ = $1;
    }|
    WHILE_LOOP {
        $$ = $1;
    }|
    FOR_LOOP {
        $$ = $1;
    }|
    FOREACH_LOOP {
        $$ = $1;
    }|
    ROUTINE_CALL TK_SCOLON {
        $$ = $1;
    }| 
    RETURN {
        $$ = $1;
    };
VARIABLE_DECLARATION:
    TK_VAR TK_IDENTIFIER TK_COLON TYPE TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($2), std::make_shared<ast::TypeNode>($4) );
    }|
    TK_VAR TK_IDENTIFIER TK_COLON TYPE TK_IS EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($2), std::make_shared<ast::TypeNode>($4),
        std::make_shared<ast::ExpressionNode>($6) );
    }|
    TK_VAR TK_IDENTIFIER TK_IS EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::VariableDeclerationNode>(
        std::make_shared<ast::IdentifierNode>($2),
        std::make_shared<ast::ExpressionNode>($4) );
    };
TYPE_DECLARATION:
    TK_TYPE TK_IDENTIFIER TK_IS TYPE TK_SCOLON {
        $$ = std::make_shared<ast::node_ptr<ast::TypeDeclerationNode>>($2, std::make_shared<ast::TypeNode>($4));
    };
TYPE:
    PRIMITIVE_TYPE {
        $$ = $1;
    }| 
    ARRAY_TYPE {
        $$ = $1;
    }|
    RECORD_TYPE {
        $$ = $1;
    }|
    TK_IDENTIFIER {
        $$ = $1;
    };
PRIMITIVE_TYPE:
    TK_INT {
        $$ = std::make_shared<ast::IntNode>();
    }|
    TK_DOUBLE {
        $$ = std::make_shared<ast::DoubleNode>();
    }|
    TK_BOOL {
        $$ = std::make_shared<ast::BoolNode>();
    }|
    TK_CHAR {
        $$ = std::make_shared<ast::CharNode>();
    }| 
    TK_STRING {
        $$ = std::make_shared<ast::StringNode>();
    };
ARRAY_TYPE:
    TK_ARRAY TK_LSQBRK EXPRESSION TK_RSQBRK TYPE {
        $$ = std::make_shared<ast::ArrayNode>($3, $5);
    };
RECORD_TYPE:
    TK_RECORD VARIABLE_DECLARATIONS TK_END {
        $$ = std::make_shared<ast::RecordNode>($2);
    };
VARIABLE_DECLARATIONS:
    VARIABLE_DECLARATION {
        $$ = std::vector<ast::node_ptr<ast::VariableDecleration>>(1, $1);
    }|
    VARIABLE_DECLARATION VARIABLE_DECLARATIONS {
        $2.push_back($1);
        $$ = $2;
    };
ASSIGNMENT:
    MODIFIABLE_PRIMARY TK_ASSIGN EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::AssignmentNode>($1, $3);
    };
PRINT:
    TK_PRINT TK_LPAREN TK_NEWLINE TK_RPAREN TK_SCOLON {
        $$ = std::make_shared<ast::PrintNode>(true);
    }|
    TK_PRINT TK_LPAREN EXPRESSION TK_RPAREN TK_SCOLON{
        $$ = std::make_shared<ast::PrintNode>($3);
    };
IF_STATEMENT:
    TK_IF EXPRESSION TK_THEN BODY TK_END {
        $$ = std::make_shared<ast::IfStatementNode>($2, $4);
    }|
    TK_IF EXPRESSION TK_THEN BODY TK_ELSE BODY TK_END {
        $$ = std::make_shared<ast::IfStatementNode>($2, $4, $6)
    };    
WHILE_LOOP:
    TK_WHILE EXPRESSION TK_LOOP BODY TK_END {
        $$ = std::make_shared<ast::WhileNode>($2, $4);
    };
FOR_LOOP:
    TK_FOR TK_IDENTIFIER RANGE TK_LOOP BODY TK_END {
        $$ = std::make_shared<ast::ForNode(
            std::make_shared<ast::IdentifierNode>($2),
            $3.first, $3.second, $5)
    };
RANGE:
    TK_IN EXPRESSION TK_DDOT EXPRESSION {
        $$ = std::make_pair<$2, $4>;
    }|
    TK_IN TK_REVERSE EXPRESSION TK_DDOT EXPRESSION {
        $$ = std::make_pair<$5, $3>;
    };
FOREACH_LOOP:
   TK_FOREACH TK_IDENTIFIER TK_FROM MODIFIABLE_PRIMARY TK_LOOP BODY TK_END {
        $$ = std::make_shared<ast::ForEachNode>(
            std::make_shared<ast::IdentifierNode>($2), $4, $6)
   };
ROUTINE_CALL:
    TK_IDENTIFIER TK_LPAREN EXPRESSION_LIST TK_RPAREN {
        $$ = std::make_shared<ast::RoutineCallNode>($1, $3);
    }|
    TK_IDENTIFIER TK_LPAREN TK_RPAREN {
        $$ = std::make_shared<ast::RoutineCallNode>($1);
    };
RETURN: //Okay
    TK_RETURN EXPRESSION TK_SCOLON {
        $$ = std::make_shared<ast::ReturnStatementNode>($2);
    };
NESTED_ACCESS:
    %empty {
        $$ = std::vector<std::variant<ast::node_ptr<ast::IdentifierNode>, ast::node_ptr<ast::ExpressionNode>>>();
    }|
    TK_DOT TK_IDENTIFIER NESTED_ACCESS {
        $3.push_back(std::make_shared<ast::IdentifierNode>($2));
        $$ = $3;
    }|
    TK_LSQBRK EXPRESSION TK_RSQBRK NESTED_ACCESS {
        $4.push_back(std::make_shared<ast::IdentifierNode>($2));
        $$ = $4;
    };
MODIFIABLE_PRIMARY : 
    TK_IDENTIFIER NESTED_ACCESS {
        $2.push_back(std::make_shared<ast::IdentifierNode>($1));
        $$ = $2;
    };
EXPRESSION: 
    RELATION {
        $$ = $1;
    }|
    TK_LPAREN RELATION TK_RPAREN {
        $$ = $2;
    }|
    RELATION TK_AND EXPRESSION {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($1,
        ast::bitwiseOperatorEnum::AND, $3);
    }|
    RELATION TK_OR EXPRESSION {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($1,
        ast::bitwiseOperatorEnum::OR, $3);
    }|
    RELATION TK_XOR EXPRESSION {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($1,
        ast::bitwiseOperatorEnum::XOR, $3);
    }|
    TK_LPAREN RELATION TK_AND EXPRESSION TK_RPAREN {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($2,
        ast::bitwiseOperatorEnum::AND, $4);
    }|
    TK_LPAREN RELATION TK_OR EXPRESSION TK_RPAREN {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($2,
        ast::bitwiseOperatorEnum::OR, $4);
    }|
    TK_LPAREN RELATION TK_XOR EXPRESSION TK_RPAREN {
        $$ = std::make_shared<ast::BitwiseOperatorNode>($2,
        ast::bitwiseOperatorEnum::XOR, $4);
    };
RELATION:
    COMPLEX {
        $$ = $1;
    }|
    COMPLEX TK_CEQ COMPLEX {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CEQ, $3);
    }|
    COMPLEX TK_CNEQ COMPLEX {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CNEQ, $3);
    }|
    COMPLEX TK_CGE COMPLEX {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CGE, $3);
    }|
    COMPLEX TK_CGT COMPLEX {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CGT, $3);
    }|
    COMPLEX TK_CLT COMPLEX {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CLT, $3);
    }|
    COMPLEX TK_CLE COMPLEX {
        $$ = std::make_shared<ast::RelationalOperatorNode>($1,
        ast::relationalOperatorEnum::CLE, $3);
    };
COMPLEX:
    SIMPLE {
        $$ = $1;
    }|
    SIMPLE TK_POW SIMPLE {
        std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::POW, $3);
    };
SIMPLE:
    FACTOR {
        $$ = $1;
    }|
    FACTOR TK_MUL SIMPLE {
        $$ = std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::MUL, $3);
    }|
    FACTOR TK_DIV SIMPLE {
        std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::DIV, $3);
    }|
    FACTOR TK_MOD SIMPLE {
        std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::MOD, $3);
    };
FACTOR:
    SUMMAND {
        $$ = $1;
    }|
    SUMMAND TK_PLUS FACTOR {
        $$ = std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::PLUS, $3);
    }|
    SUMMAND TK_MINUS FACTOR {
        $$ = std::make_shared<ast::ArithmeticOperatorNode>($1, 
        ast::arithmeticOperatorEnum::MINUS, $3);
    }; 
// This doesn't care if we get unclosed paranthesis, is this a syntax error or a symantic error?
SUMMAND:
    PRIMARY {
        $$ = $1;
    };
PRIMARY:
    TK_TRUE {
        $$ = true;
    }|
    TK_FALSE {
        $$ = false;
    }|
    TK_INTEGER_LITERAL {
        std::cout<<$1<<" ";
        $$ = $1;
    }|
    TK_NOT TK_INTEGER_LITERAL {
        std::cout<<$2<<" ";
        $$ = (! $2);
    }|
    SIGN TK_INTEGER_LITERAL {
        std::cout<<$2<<" ";
        $$ = ($1 * $2);   
    }|
    SIGN TK_DOUBLE_LITERAL {
        std::cout<<$2<<" ";
        $$ = ($1 * $2);
    }|
    TK_DOUBLE_LITERAL {
        std::cout<<$1<<" ";
        $$ = $1;
    }|
    MODIFIABLE_PRIMARY {
        $$ = $1;
    }|
    ROUTINE_CALL {
        $$ = $1;
    }|
    TK_LSQBRK EXPRESSION_LIST TK_RSQBRK {

    }|
    TK_CHARACTER_LITERAL {

    }|
    TK_STRING_LITERAL {

    };
SIGN:
    TK_PLUS {
        $$ = 1;
    }|
    TK_MINUS {
        $$ = -1;
    };
EXPRESSION_LIST:
    EXPRESSION {

    }|
    EXPRESSION_LIST TK_COMMA EXPRESSION {

    };
%%

void carbonic_c::Parser::error(const std::string& msg) {
    std::cerr << msg << '\n';
}