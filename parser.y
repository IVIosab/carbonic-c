%require "3.0"
%{
#include <iostream>
#include <string>
#include "lexer.h"
#include <identifierTable.h>
using namespace std;
%}
%union{
    //define the AST here later on
    string stringLtrl;
    double doubleLtrl;
    long long int intLtrl;
}
%token TK_VAR TK_TYPE
%token TK_INT TK_DOUBLE TK_BOOL TK_CHAR TK_ARRAY TK_RECORD TK_ROUTINE TK_IS TK_NOT
%token TK_WHILE TK_LOOP TK_END TK_FOR TK_FOREACH TK_FROM TK_RETURN
%token TK_IF TK_THEN TK_ELSE TK_IN TK_REVERSE 
%token TK_IDENTIFIER TK_ASSIGN
%token TK_STRING_LITERAL TK_DOUBLE_LITERAL,TK_INTEGER_LITERAL TK_CHARACTER_LITERAL TK_TRUE TK_FALSE
%token TK_PRINT
%token TK_CEQ TK_CNEQ TK_CLT TK_CLE TK_CGT TK_CGE
%token TK_LPAREN TK_RPAREN TK_LBRACK TK_RBRACK TK_LSQBRK TK_RSQBRK 
%token TK_SQUOT TK_DOT TK_COMMA TK_COLON TK_SCOLON TK_DDOT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV
%token TK_NEWLINE
%token TK_MOD TK_POW TK_AND TK_OR TK_XOR
%right '='
%left '+' '-'
%left '*' '/'
%right '^'

%type <stringLtrl> TK_IDENTIFIER TK_STRING_LITERAL
%type <intLtrl> TK_INTEGER_LITERAL
%type <doubleLtrl> TK_DOUBLE_LITERAL

%define api.namespace { carbonic_c }
%code requires
{
    #include <iostream>
    using namespace std;
    namespace carbonic_c {
        class Lexer;
    }

}

%start program
%%
//TODO: Grammar rules and actions
PROGRAM:
    SIMPLE_DECLERATION |
    ROUTINE_DECLERATION ;
SIMPLE_DECLERATION: 
    VARIABLE_DECLERATION |
    TYPE_DECLERATION;
ROUTINE_DECLERATION:
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN PARAMETERS TK_RPAREN TK_COLON TYPE TK_IS BODY TK_END |
    TK_ROUTINE TK_IDENTIFIER TK_LPAREN PARAMETERS TK_RPAREN TK_IS BODY TK_END ;
PARAMETER: 
    TK_IDENTIFIER TK_COLON TYPE {}|
    TK_IDENTIFIER TK_COLON TYPE TK_COMMA PARAMETER{};
PARAMETERS:
    %empty |
    PARAMETER;
BODY:
    %empty {}|
    VARIABLE_DECLERATION BODY{}|
    STATEMENT BODY{}
    ;
STATEMENT:
    VARIABLE_DECLERATION {}|
    ASSIGNMENT {}|
    PRINT {}|
    IF_STATEMENT {}|
    WHILE_LOOP {}|
    FOR_LOOP {}|
    FOREACH_LOOP {}|
    ROUTINE_CALL TK_SCOLON {}|
    RETURN_STATEMENT{}
    ;
VARIABLE_DECLERATION: 
    TK_VAR TK_IDENTIFIER TK_IS EXPRESSION TK_SCOLON {}|
    TK_VAR TK_IDENTIFIER TK_COLON TYPE TK_IS EXPRESSION TK_SCOLON {}; 
TYPE_DECLERATION: 
    TK_TYPE TK_IDENTIFIER TK_IS PRIMITIVE_TYPE TK_SCOLON {}; // primitive type or also previously defined types too?
TYPE:
    PRIMITIVE_TYPE | 
    ARRAY_TYPE |
    RECORD_TYPE |
    TK_IDENTIFIER {};
PRIMITIVE_TYPE:
    TK_INT {} |
    TK_DOUBLE {} |
    TK_BOOL {} |
    TK_CHAR {};
ARRAY_TYPE:
    TK_ARRAY TK_LSQBRK EXPRESSION TK_RSQBRK PRIMITIVE_TYPE {};
RECORD_TYPE:
    TK_RECORD TK_LBRACK VARIABLE_DECLERATIONS TK_RBRACK {};
VARIABLE_DECLERATIONS: 
    VARIABLE_DECLERATION {}|
    VARIABLE_DECLERATION VARIABLE_DECLERATIONS {}
    ;
ASSIGNMENT: 
    MODIFABLE_PRIMARY TK_ASSIGN EXPRESSION TK_SCOLON {}
;
PRINT: 
    TK_PRINT TK_LPAREN TK_STRING_LITERAL  TK_RPAREN TK_SCOLON {}
    ;
IF_STATEMENT: 
    TK_IF EXPRESSION TK_THEN BODY TK_END {}|
    TK_IF EXPRESSION TK_THEN BODY TK_ELSE BODY TK_END {}
    ;    
WHILE_LOOP: 
   TK_WHILE EXPRESSION TK_LOOP BODY TK_END {};
FOR_LOOP: 
    TK_FOR TK_IDENTIFIER RANGE TK_LOOP BODY TK_END {};
RANGE : 
    TK_IN EXPRESSION TK_DDOT EXPRESSION {}|
    TK_IN TK_REVERSE TK_DDOT EXPRESSION {}
    ;
FOREACH_LOOP:
   TK_FOREACH TK_IDENTIFIER TK_FROM MODIFABLE_PRIMARY TK_LOOP BODY TK_END {};
ROUTINE_CALL: 
    TK_IDENTIFIER TK_LPAREN PARAMETER TK_RPAREN {}
    ;
RETURN_STATEMENT: 
    TK_RETURN EXPRESSION TK_SCOLON {};
NESTED_ACCESS:
    %empty {}|
    TK_DOT TK_IDENTIFIER NESTED_ACCESS {}|
    TK_LSQBRK EXPRESSION TK_RBRACK NESTED_ACCESS {}
    ;
MODIFABLE_PRIMARY : 
    TK_IDENTIFIER {}|
    TK_IDENTIFIER TK_DOT TK_IDENTIFIER NESTED_ACCESS {}|
;
EXPRESSION: 
    RELATION {}|
    RELATION TK_AND EXPRESSION {}|
    RELATION TK_OR EXPRESSION {}|
    RELATION TK_XOR EXPRESSION {}
    ;
RELATION: 
    COMPLEX {}|
    COMPLEX TK_CEQ COMPLEX {}|
    COMPLEX TK_CNEQ COMPLEX {}|
    COMPLEX TK_CGE COMPLEX {}|
    COMPLEX TK_CGT COMPLEX {}|
    COMPLEX TK_CLT COMPLEX {}|
    COMPLEX TK_CLE COMPLEX {}|
    COMPLEX TK_NOT COMPLEX {}
    ;
COMPLEX:
    SIMPLE {}|
    SIMPLE TK_POW COMPLEX {}
    ;
SIMPLE:
    FACTOR {}|
    FACTOR TK_MUL SIMPLE {}|
    FACTOR TK_DIV SIMPLE {}|
    FACTOR TK_MOD SIMPLE {}
    ;
FACTOR:
    SUMMAND {}|
    SUMMAND TK_PLUS FACTOR {}|
    SUMMAND TK_MINUS FACTOR {}|
    ;
SUMMAND:
    PRIMARY {}|
    EXPRESSION {}
    ;
PRIMARY:
    TK_TRUE {}|
    TK_FALSE {}|
    TK_INTEGER_LITERAL {}|
    TK_NOT TK_INTEGER_LITERAL {}|
    SIGN TK_INTEGER_LITERAL {}|
    SIGN TK_DOUBLE_LITERAL {}|
    TK_DOUBLE_LITERAL {}|
    TK_IDENTIFIER {}|
    MODIFABLE_PRIMARY {}|
    ROUTINE_CALL {}
    ;
SIGN:
    TK_PLUS {}|
    TK_MINUS {}
    ;
%%
// C++ functions

// Called by yyparser when errors are faced.
void yyerror(string error_message){
    cout << "PARSING ERROR: " << error_message << '\n';
}
void yyparse(){
    //TODO: implement, it will get next token and be the driver to this parser.
}
int main(int argc, char* argv[]){
    extern FILE *yyin;
    argv++;
    argc--;
    yyin = fopen(argv[0], ”r” );
    yydebug = 1;
    errors = 0;
    yyparse ();
    return 0;
}

